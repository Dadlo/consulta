<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="description" content="">
        <meta name="author" content="">
        <link rel="shortcut icon" href="">
        <title>Consulta para a prova de CG</title>

        <!-- Bootstrap core CSS -->
        <link href="//netdna.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css" rel="stylesheet">
        <link href="//netdna.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap-theme.min.css" rel="stylesheet">
        
        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.2/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
        <![endif]-->
    </head>

    <body>
        <div class="container">
            <ul class="nav nav-tabs" role="tablist" id="myTab">
              <li class="active"><a href="#home" role="tab" data-toggle="tab">janela.cpp</a></li>
              <li><a href="#profile" role="tab" data-toggle="tab">triangulo.cpp</a></li>
              <li><a href="#messages" role="tab" data-toggle="tab">triangulo_2.cpp</a></li>
              <li><a href="#settings" role="tab" data-toggle="tab">beki.cpp</a></li>
            </ul>

<div class="tab-content">
<div class="tab-pane fade in active" id="home">
            <h1>janela.cpp</h1>
<pre>
//COLOCAR < ANTES DE CADA UM DOS INCLUDES
#include windows.h> 
#include windowsx.h>

LRESULT CALLBACK WindowProc(HWND hWnd,
                         UINT message,
                         WPARAM wParam,
                         LPARAM lParam);

int WINAPI WinMain(HINSTANCE hInstance,
                   HINSTANCE hPrevInstance,
                   LPSTR lpCmdLine,
                   int nCmdShow)
{
    HWND hWnd;
    WNDCLASSEX wc;

    ZeroMemory(&wc, sizeof(WNDCLASSEX));

    wc.cbSize = sizeof(WNDCLASSEX);
    wc.style = CS_HREDRAW | CS_VREDRAW;
    wc.lpfnWndProc = WindowProc;
    wc.hInstance = hInstance;
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)COLOR_WINDOW;
    wc.lpszClassName = L"WindowClass1";

    RegisterClassEx(&wc);

    hWnd = CreateWindowEx(NULL,
                          L"WindowClass1",    
                          L"Our First Windowed Program",    
                          WS_OVERLAPPEDWINDOW,    
                          300,    
                          300,    
                          500,    
                          400,    
                          NULL,   
                          NULL,   
                          hInstance, 
                          NULL);   

    ShowWindow(hWnd, nCmdShow);

    MSG msg;

    while(TRUE)
    {
        while(PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
        {
            TranslateMessage(&msg);

            DispatchMessage(&msg);
        }

        if(msg.message == WM_QUIT)
            break;

        // Seu c√≥digo!
    }

    return msg.wParam;
}

LRESULT CALLBACK WindowProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch(message)
    {
        case WM_DESTROY:
            {
                PostQuitMessage(0);
                return 0;
            } break;
    }

    return DefWindowProc (hWnd, message, wParam, lParam);
}
</pre>
</div>




<div class="tab-pane fade" id="profile">
<h1>triangulo.cpp</h1>
<pre>
//COLOCAR < ANTES DE CADA UM DOS INCLUDES
#include windows.h>
#include windowsx.h>
#include d3d9.h>

#define SCREEN_WIDTH 800
#define SCREEN_HEIGHT 600

#pragma comment (lib, "d3d9.lib")

LPDIRECT3D9 d3d;    
LPDIRECT3DDEVICE9 d3ddev;    
LPDIRECT3DVERTEXBUFFER9 v_buffer = NULL;    

void initD3D(HWND hWnd);   
void render_frame(void);   
void cleanD3D(void);   
void init_graphics(void);    

struct CUSTOMVERTEX {FLOAT X, Y, Z, RHW; DWORD COLOR;};
#define CUSTOMFVF (D3DFVF_XYZRHW | D3DFVF_DIFFUSE)

LRESULT CALLBACK WindowProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);


int WINAPI WinMain(HINSTANCE hInstance,
                   HINSTANCE hPrevInstance,
                   LPSTR lpCmdLine,
                   int nCmdShow)
{
    HWND hWnd;
    WNDCLASSEX wc;

    ZeroMemory(&wc, sizeof(WNDCLASSEX));

    wc.cbSize = sizeof(WNDCLASSEX);
    wc.style = CS_HREDRAW | CS_VREDRAW;
    wc.lpfnWndProc = WindowProc;
    wc.hInstance = hInstance;
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.lpszClassName = L"WindowClass";

    RegisterClassEx(&wc);

    hWnd = CreateWindowEx(NULL,
                          L"WindowClass",
                          L"Our Direct3D Program",
                          WS_OVERLAPPEDWINDOW,
                          0, 0,
                          SCREEN_WIDTH, SCREEN_HEIGHT,
                          NULL,
                          NULL,
                          hInstance,
                          NULL);

    ShowWindow(hWnd, nCmdShow);

    initD3D(hWnd);

    MSG msg;

    while(TRUE)
    {
        while(PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }

        if(msg.message == WM_QUIT)
            break;

        render_frame();
    }

    cleanD3D();

    return msg.wParam;
}


LRESULT CALLBACK WindowProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch(message)
    {
        case WM_DESTROY:
            {
                PostQuitMessage(0);
                return 0;
            } break;
    }

    return DefWindowProc (hWnd, message, wParam, lParam);
}


void initD3D(HWND hWnd)
{
    d3d = Direct3DCreate9(D3D_SDK_VERSION);

    D3DPRESENT_PARAMETERS d3dpp;

    ZeroMemory(&d3dpp, sizeof(d3dpp));
    d3dpp.Windowed = TRUE;
    d3dpp.SwapEffect = D3DSWAPEFFECT_DISCARD;
    d3dpp.hDeviceWindow = hWnd;
    d3dpp.BackBufferFormat = D3DFMT_X8R8G8B8;
    d3dpp.BackBufferWidth = SCREEN_WIDTH;
    d3dpp.BackBufferHeight = SCREEN_HEIGHT;

    d3d->CreateDevice(D3DADAPTER_DEFAULT,
                      D3DDEVTYPE_HAL,
                      hWnd,
                      D3DCREATE_SOFTWARE_VERTEXPROCESSING,
                      &d3dpp,
                      &d3ddev);

    init_graphics();
}

void render_frame(void)
{
    d3ddev->Clear(0, NULL, D3DCLEAR_TARGET, D3DCOLOR_XRGB(0, 0, 0), 1.0f, 0);

    d3ddev->BeginScene();

        d3ddev->SetFVF(CUSTOMFVF);

        d3ddev->SetStreamSource(0, v_buffer, 0, sizeof(CUSTOMVERTEX));

        d3ddev->DrawPrimitive(D3DPT_TRIANGLELIST, 0, 1);

    d3ddev->EndScene();

    d3ddev->Present(NULL, NULL, NULL, NULL);
}

void cleanD3D(void)
{
    v_buffer->Release();
    d3ddev->Release();
    d3d->Release();
}

void init_graphics(void)
{
    CUSTOMVERTEX vertices[] =
    {
        { 400.0f, 62.5f, 0.5f, 1.0f, D3DCOLOR_XRGB(0, 0, 255), },
        { 650.0f, 500.0f, 0.5f, 1.0f, D3DCOLOR_XRGB(0, 255, 0), },
        { 150.0f, 500.0f, 0.5f, 1.0f, D3DCOLOR_XRGB(255, 0, 0), },
    };

    d3ddev->CreateVertexBuffer(3*sizeof(CUSTOMVERTEX),
                               0,
                               CUSTOMFVF,
                               D3DPOOL_MANAGED,
                               &v_buffer,
                               NULL);

    VOID* pVoid;

    v_buffer->Lock(0, 0, (void**)&pVoid, 0);
    memcpy(pVoid, vertices, sizeof(vertices));
    v_buffer->Unlock();
}
        </pre>
</div>


<div class="tab-pane fade" id="messages">
        <h1>triangulo_2.cpp</h1>
        <pre>
//COLOCAR < ANTES DE CADA UM DOS INCLUDES
#include windows.h>
#include windowsx.h>
#include d3d9.h>
#include d3dx9.h>

#define SCREEN_WIDTH 800
#define SCREEN_HEIGHT 600

#pragma comment (lib, "d3d9.lib")
#pragma comment (lib, "d3dx9.lib")

LPDIRECT3D9 d3d;    
LPDIRECT3DDEVICE9 d3ddev;    
LPDIRECT3DVERTEXBUFFER9 v_buffer = NULL;    

void initD3D(HWND hWnd);    
void render_frame(void);    
void cleanD3D(void);    
void init_graphics(void);    

struct CUSTOMVERTEX {FLOAT X, Y, Z; DWORD COLOR;};
#define CUSTOMFVF (D3DFVF_XYZ | D3DFVF_DIFFUSE)

LRESULT CALLBACK WindowProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);


int WINAPI WinMain(HINSTANCE hInstance,
                   HINSTANCE hPrevInstance,
                   LPSTR lpCmdLine,
                   int nCmdShow)
{
    HWND hWnd;
    WNDCLASSEX wc;

    ZeroMemory(&wc, sizeof(WNDCLASSEX));

    wc.cbSize = sizeof(WNDCLASSEX);
    wc.style = CS_HREDRAW | CS_VREDRAW;
    wc.lpfnWndProc = WindowProc;
    wc.hInstance = hInstance;
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.lpszClassName = L"WindowClass";

    RegisterClassEx(&wc);

    hWnd = CreateWindowEx(NULL, L"WindowClass", L"Our Direct3D Program",
                          WS_OVERLAPPEDWINDOW, 0, 0, SCREEN_WIDTH, SCREEN_HEIGHT,
                          NULL, NULL, hInstance, NULL);

    ShowWindow(hWnd, nCmdShow);

    initD3D(hWnd);

    //Loop principal

    MSG msg;

    while(TRUE)
    {
        while(PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }

        if(msg.message == WM_QUIT)
            break;

        render_frame();
    }

    cleanD3D();

    return msg.wParam;
}


LRESULT CALLBACK WindowProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch(message)
    {
        case WM_DESTROY:
            {
                PostQuitMessage(0);
                return 0;
            } break;
    }

    return DefWindowProc (hWnd, message, wParam, lParam);
}

void initD3D(HWND hWnd)
{
    d3d = Direct3DCreate9(D3D_SDK_VERSION);

    D3DPRESENT_PARAMETERS d3dpp;

    ZeroMemory(&d3dpp, sizeof(d3dpp));
    d3dpp.Windowed = TRUE;
    d3dpp.SwapEffect = D3DSWAPEFFECT_DISCARD;
    d3dpp.hDeviceWindow = hWnd;
    d3dpp.BackBufferFormat = D3DFMT_X8R8G8B8;
    d3dpp.BackBufferWidth = SCREEN_WIDTH;
    d3dpp.BackBufferHeight = SCREEN_HEIGHT;

    d3d->CreateDevice(D3DADAPTER_DEFAULT,
                      D3DDEVTYPE_HAL,
                      hWnd,
                      D3DCREATE_SOFTWARE_VERTEXPROCESSING,
                      &d3dpp,
                      &d3ddev);

    init_graphics();

    d3ddev->SetRenderState(D3DRS_LIGHTING, FALSE);
}


void render_frame(void)
{
    //d3ddev->Clear(0, NULL, D3DCLEAR_TARGET, D3DCOLOR_XRGB(0, 0, 0), 1.0f, 0);

    d3ddev->BeginScene();

    d3ddev->SetFVF(CUSTOMFVF);

   
    static float index = 0.0f; index-=20.55f;
    static float index2 = 0.0f; index2+=0.01f;

    D3DXMATRIX matRotateY;

    D3DXMatrixRotationZ(&matRotateY, index);



    D3DXMATRIX matScaleY;

    D3DXMatrixScaling(&matScaleY, 0.2f, 0.2f, 0.5f);

    D3DXMATRIX matTransY;

    D3DXMatrixTranslation(&matTransY, index2 , 0, 0);



    d3ddev->SetTransform(D3DTS_WORLD, &(matRotateY * matTransY * matRotateY * matRotateY));

    D3DXMATRIX matView;

    D3DXMatrixLookAtLH(&matView,
                       &D3DXVECTOR3 (0.0f, 0.0f, 10.0f),//pos
                       &D3DXVECTOR3 (0.0f, 0.0f, 0.0f),//ponto para o qual a camera esta olhando
                       &D3DXVECTOR3 (0.0f, 1.0f, 0.0f));//inclinacao da camera

    d3ddev->SetTransform(D3DTS_VIEW, &matView);

    D3DXMATRIX matProjection;

    D3DXMatrixPerspectiveFovLH(&matProjection,
                               D3DXToRadian(45),    //angulo da lente
                               (FLOAT)SCREEN_WIDTH / (FLOAT)SCREEN_HEIGHT, //aspect rate (4:3 , etc)
                               1.0f,    //plano de corte proximo (near clipping pane)
                               100.0f);    //plano de corte distante (far clipping pane)

    d3ddev->SetTransform(D3DTS_PROJECTION, &matProjection);    

    d3ddev->SetStreamSource(0, v_buffer, 0, sizeof(CUSTOMVERTEX));

    d3ddev->DrawPrimitive(D3DPT_TRIANGLESTRIP, 0, 2);

    d3ddev->EndScene();

    d3ddev->Present(NULL, NULL, NULL, NULL);
}


void cleanD3D(void)
{
    v_buffer->Release();    
    d3ddev->Release();    
    d3d->Release();    
}

void init_graphics(void)
{
    CUSTOMVERTEX vertices[] = 
    {
        { 3.0f, 3.0f, 0.0f, D3DCOLOR_XRGB(0, 255, 0), },
        { -3.0f, 3.0f, 0.0f, D3DCOLOR_XRGB(255, 0, 0), },
        { 3.0f, -3.0f, 0.0f, D3DCOLOR_XRGB(0, 0, 255), },
        { -3.0f, -3.0f, 0.0f, D3DCOLOR_XRGB(255, 0, 0), },
        
    };

    d3ddev->CreateVertexBuffer(4*sizeof(CUSTOMVERTEX),
                               0,
                               CUSTOMFVF,
                               D3DPOOL_MANAGED,
                               &v_buffer,
                               NULL);

    VOID* pVoid;

    v_buffer->Lock(0, 0, (void**)&pVoid, 0);
    memcpy(pVoid, vertices, sizeof(vertices));
    v_buffer->Unlock();
}

       </pre>
</div>
<div class="tab-pane fade" id="settings">





       <h1>beki.cpp</h1>
       <h4>"beki era o nome do vegeta em um jogo piratao de dragon ball q eu tinha pra gameboy" -FERRES, Lucas Vinicius Brandt</h4>
       <p class="text-muted">Pra quem n√£o entendeu, esse √© o c√≥digo do coelho</p>
            
       <pre>
//COLOCAR < ANTES DE CADA UM DOS INCLUDES            
#include string>            
#include iostream>
#include Windows.h>
#include d3d9.h>
#include d3dx9.h>
#include math.h>

#pragma comment (lib, "d3d9.lib")
#pragma comment (lib, "d3dx9.lib")


#define CUSTOMFVF (D3DFVF_XYZ | D3DFVF_NORMAL) 

using namespace std;

CONST UINT SCREEN_WIDTH (1024);
CONST UINT SCREEN_HEIGHT (768);
CONST FLOAT ASPECT_RATIO ((FLOAT)SCREEN_WIDTH/(FLOAT)SCREEN_HEIGHT);

LPD3DXMESH nave;      
DWORD numMateriais;
D3DMATERIAL9* material;   
LPDIRECT3DTEXTURE9* textura; //1-) ponteiro para textura

std::wstring caminhoApp;

int appRodando = 1;
float angulo = 0;

 struct OURCUSTOMVERTEX 
 {
     float x,y,z;
     D3DVECTOR NORMAL;
 };
 
 LRESULT CALLBACK TratamentoEventos(HWND han_Wind,UINT uint_Message,WPARAM parameter1,LPARAM parameter2)
 {
     switch(uint_Message)
     {
         case WM_KEYDOWN:
         {
             appRodando = 0;
             break;
         }
         break;
     }
 
     return DefWindowProc(han_Wind,uint_Message,parameter1,parameter2);
 }
 
 HWND NewWindow(LPCTSTR str_Title,int int_XPos, int int_YPos, int int_Width, int int_Height)
 {
     WNDCLASSEX estruturaJanela;
 
     estruturaJanela.cbSize = sizeof(WNDCLASSEX);
     estruturaJanela.style = CS_HREDRAW | CS_VREDRAW;
     estruturaJanela.lpfnWndProc = TratamentoEventos;
     estruturaJanela.cbClsExtra = 0;
     estruturaJanela.cbWndExtra = 0;
     estruturaJanela.hInstance = GetModuleHandle(NULL);
     estruturaJanela.hIcon = NULL;
     estruturaJanela.hCursor = NULL;
     estruturaJanela.hbrBackground = GetSysColorBrush(COLOR_BTNFACE);
     estruturaJanela.lpszMenuName = NULL;
     estruturaJanela.lpszClassName = L"WindowClassName";
     estruturaJanela.hIconSm = LoadIcon(NULL,IDI_APPLICATION);
 
     RegisterClassEx(&estruturaJanela);
 
     return CreateWindowEx(WS_EX_CONTROLPARENT, L"WindowClassName", str_Title, WS_OVERLAPPED | WS_POPUP, 0, 0, int_Width, int_Height, NULL, NULL, GetModuleHandle(NULL), NULL);
 }

void CriaLuz(LPDIRECT3DDEVICE9 placaVideo)
{
    D3DLIGHT9 light;
    D3DMATERIAL9 material;

    ZeroMemory(&light, sizeof(light));
    light.Type = D3DLIGHT_DIRECTIONAL;    
    light.Diffuse = D3DXCOLOR(0.5f, 0.9f, 0.5f, 1.0f); //cor da luz
    light.Position = D3DXVECTOR3(0.0f, 10.0f, 40.0f);
    light.Direction = D3DXVECTOR3(0.0f, -1.0f, -1.0f);
    light.Range = 50.0f;    //tamanho do cone
    light.Phi = D3DXToRadian(80.0f);     
    light.Theta = D3DXToRadian(40.0f);    
    light.Falloff = 1.0f;    

    placaVideo->SetLight(0, &light);
    placaVideo->LightEnable(0, TRUE);

    ZeroMemory(&material, sizeof(D3DMATERIAL9));
    material.Diffuse = D3DXCOLOR(1.0f, 1.0f, 1.0f, 1.0f);
    material.Ambient = D3DXCOLOR(1.0f, 1.0f, 1.0f, 1.0f);

    placaVideo->SetMaterial(&material); 
}
 
 LPDIRECT3DDEVICE9 InicializaPlacaVideo(HWND han_WindowToBindTo)
 {

     LPDIRECT3D9 directX;
     LPDIRECT3DDEVICE9 placaVideo;
 
     directX = Direct3DCreate9(D3D_SDK_VERSION);
     if (directX == NULL)
     {
         MessageBox(han_WindowToBindTo,L"DirectX Runtime library not installed!",L"InicializaPlacaVideo()",MB_OK);
     }
 
     D3DPRESENT_PARAMETERS parametrosApresentacao;
     ZeroMemory( &parametrosApresentacao, sizeof(parametrosApresentacao) );
     parametrosApresentacao.Windowed = FALSE;
     parametrosApresentacao.BackBufferWidth = 1024;
     parametrosApresentacao.BackBufferHeight = 768;
     parametrosApresentacao.SwapEffect = D3DSWAPEFFECT_DISCARD;
     parametrosApresentacao.BackBufferFormat = D3DFMT_A8R8G8B8;
     parametrosApresentacao.BackBufferWidth = SCREEN_WIDTH;
     parametrosApresentacao.BackBufferHeight = SCREEN_HEIGHT;

     parametrosApresentacao.EnableAutoDepthStencil = TRUE;   
     parametrosApresentacao.AutoDepthStencilFormat = D3DFMT_D16; 
 
      if (FAILED(directX->CreateDevice(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, han_WindowToBindTo, D3DCREATE_HARDWARE_VERTEXPROCESSING, &parametrosApresentacao, &placaVideo)))
      {
             if (FAILED(directX->CreateDevice(D3DADAPTER_DEFAULT, D3DDEVTYPE_REF, han_WindowToBindTo, D3DCREATE_SOFTWARE_VERTEXPROCESSING, &parametrosApresentacao, &placaVideo)))
             {
                 MessageBox(han_WindowToBindTo,L"Failed to create even the reference device!",L"InicializaPlacaVideo()",MB_OK);
             }
      }

      
      LPD3DXBUFFER bufferMaterialNave; 
      std::wstring arquivo = L"bunny.x";
      std::wstring caminhoModelo;
      caminhoModelo = caminhoApp.c_str();
      caminhoModelo.append(arquivo);

      D3DXLoadMeshFromX(caminhoModelo.c_str(),    
                  D3DXMESH_SYSTEMMEM,    
                  placaVideo,    
                  NULL,    
                  &bufferMaterialNave,    
                  NULL,    
                  &numMateriais,    
                  &nave);
    
    D3DXMATERIAL* tempMaterials = (D3DXMATERIAL*)bufferMaterialNave->GetBufferPointer();

    material = new D3DMATERIAL9[numMateriais];
    textura = new LPDIRECT3DTEXTURE9[numMateriais]; //2-) Iniciamos o array

    for(DWORD i = 0; i < numMateriais; i++)    
    {
        material[i] = tempMaterials[i].MatD3D;    
        material[i].Ambient = material[i].Diffuse;    

        //3-) Carregamos o material
        try
        {
            if(FAILED(D3DXCreateTextureFromFileA(
                                            placaVideo,
                                            tempMaterials[i].pTextureFilename,
                                            &textura[i])))
            {
                textura[i] = NULL;
            }
        }
        catch(exception)
        {
            textura[i] = NULL;
        }
    }


      placaVideo->SetRenderState(D3DRS_LIGHTING, TRUE); 
      placaVideo->SetRenderState(D3DRS_AMBIENT, D3DCOLOR_XRGB(50, 50, 50));    
      placaVideo->SetRenderState(D3DRS_ZENABLE, TRUE);    
      placaVideo->SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE); 

      //6-) Filtro de Textura
        placaVideo->SetSamplerState(0, D3DSAMP_MAXANISOTROPY, 8);
        placaVideo->SetSamplerState(0, D3DSAMP_MINFILTER, D3DTEXF_ANISOTROPIC);
        placaVideo->SetSamplerState(0, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);
        placaVideo->SetSamplerState(0, D3DSAMP_MIPFILTER, D3DTEXF_LINEAR);

      CriaLuz(placaVideo);
 
     return placaVideo;
 }
 
 void DesenhaCena(LPDIRECT3DDEVICE9 placaVideo)
 {
     placaVideo->Clear(0, NULL, D3DCLEAR_ZBUFFER, D3DCOLOR_XRGB(0, 0, 0), 1.0f, 0); 
     placaVideo->Clear(0, NULL, D3DCLEAR_TARGET, D3DCOLOR_XRGB(0,0,0), 1.0f, 0);
     placaVideo->BeginScene();
 
     placaVideo->SetFVF(CUSTOMFVF);

     angulo += .38f;
     D3DXMATRIX matWorldX;
     D3DXMATRIX matWorldY;
     D3DXMATRIX matWorldTransZ;
     D3DXMatrixRotationX(&matWorldX, D3DXToRadian(-90));
     D3DXMatrixRotationY(&matWorldY, D3DXToRadian(angulo));
     D3DXMatrixTranslation(&matWorldTransZ, 0, 0, angulo);
     placaVideo->SetTransform(D3DTS_WORLD, &(matWorldX * matWorldY * matWorldTransZ));

     D3DXMATRIX matView;
     D3DXMatrixLookAtLH(
         &matView,
         &D3DXVECTOR3(0.0f, 2.0f, 500.0f), //pos da camera
         &D3DXVECTOR3(0.0f, 0.0f, 0.0f), //local p onde a camera esta olhando
         &D3DXVECTOR3(0.0f, 1.0f, 0.0f)); //vector up da camera

     placaVideo->SetTransform(D3DTS_VIEW, &matView);

     D3DXMATRIX matProjection;

     D3DXMatrixPerspectiveFovLH(
         &matProjection,
         D3DXToRadian(45),
         ASPECT_RATIO,
         1.0f,
         1000.0f);
     placaVideo->SetTransform(D3DTS_PROJECTION, &matProjection);

    for(DWORD i = 0; i < numMateriais; i++)    
    {
        placaVideo->SetMaterial(&material[i]); 
        nave->DrawSubset(i); 

        //4-) Desenhamos o material
        if(textura[i] != NULL)    
        {
            placaVideo->SetTexture(0, textura[i]);   
        }
    }
 
     placaVideo->EndScene();
     placaVideo->Present(NULL, NULL, NULL, NULL);
 }
 
 int WINAPI WinMain(HINSTANCE hInstance,HINSTANCE hPreviousInstance,LPSTR lpcmdline,int nCmdShow)
 {
     //5-) Estamos setando o diret√≥rio principal para a aplica√ß√£o.
     //caminhoApp = L"C:\\Documents and Settings\\Willians\\Desktop\\FATEC\\Material\\CG\\Prox_Aula\\DirectX_Meshes_X_Texturized\\Debug\\";
     //SetCurrentDirectory(caminhoApp.c_str());

     MSG msg_Message;
 
     HWND han_Window                   = NewWindow(L"DIRECTX", 0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
     LPDIRECT3DDEVICE9 placaVideo      = InicializaPlacaVideo(han_Window);
 
     while(appRodando)
     {
         if(PeekMessage(&msg_Message,han_Window,0,0,PM_REMOVE))
         {
             DispatchMessage(&msg_Message);
         }
         DesenhaCena(placaVideo);
     }
 
     nave->Release();
     placaVideo->Release();
     DestroyWindow(han_Window);
 
     return 0;
 }
        </pre>
    </div>


    </div>
    </div>
        <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
        <!-- compiled and minified Bootstrap JavaScript -->
        <script src="//netdna.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js"></script>
        <script>
        $('#myTab a').click(function (e) {
          e.preventDefault()
          $(this).tab('show')
        })
        </script<
    </body>
</html>
